{"version":3,"file":"static/js/2352.53a5c439.chunk.js","mappings":"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","sources":["../node_modules/@ucast/core/src/Condition.ts","../node_modules/@ucast/core/src/utils.ts","../node_modules/@ucast/core/src/builder.ts","../node_modules/@ucast/core/src/parsers/defaultInstructionParsers.ts","../node_modules/@ucast/core/src/parsers/ObjectQueryParser.ts","../node_modules/@ucast/core/src/interpreter.ts","../node_modules/@ucast/core/src/index.ts","../node_modules/@ucast/mongo/src/instructions.ts","../node_modules/@ucast/mongo/src/MongoQueryParser.ts","../node_modules/@ucast/mongo/src/index.ts","../node_modules/@ucast/js/src/utils.ts","../node_modules/@ucast/js/src/interpreter.ts","../node_modules/@ucast/js/src/interpreters.ts","../node_modules/@ucast/js/src/defaults.ts","../node_modules/@ucast/mongo2js/src/factory.ts","../node_modules/@ucast/core/src/translator.ts","../node_modules/@casl/ability/src/utils.ts","../node_modules/@casl/ability/src/Rule.ts","../node_modules/@casl/ability/src/structures/LinkedItem.ts","../node_modules/@casl/ability/src/RuleIndex.ts","../node_modules/@casl/ability/src/PureAbility.ts","../node_modules/@casl/ability/src/matchers/conditions.ts","../node_modules/@casl/ability/src/matchers/field.ts","../node_modules/@casl/ability/src/Ability.ts","../node_modules/@casl/ability/src/AbilityBuilder.ts","../node_modules/@casl/ability/src/ForbiddenError.ts","../node_modules/@casl/react/src/Can.ts","views/apps/accessControlCASL/AccessControl.js","components/CreationModification.js","components/ComponentCard.js"],"sourcesContent":["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n","import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n","import {\n  CompoundCondition,\n  FieldCondition,\n  NamedInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n  DocumentInstruction,\n  Comparable,\n  ITSELF,\n  NULL_CONDITION,\n  FieldParsingContext,\n  optimizedCompoundCondition,\n  ObjectQueryFieldParsingContext,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nfunction ensureIsArray(instruction: NamedInstruction, value: unknown) {\n  if (!Array.isArray(value)) {\n    throw new Error(`\"${instruction.name}\" expects value to be an array`);\n  }\n}\n\nfunction ensureIsNonEmptyArray(instruction: NamedInstruction, value: unknown[]) {\n  ensureIsArray(instruction, value);\n\n  if (!value.length) {\n    throw new Error(`\"${instruction.name}\" expects to have at least one element in array`);\n  }\n}\n\nfunction ensureIsComparable(instruction: NamedInstruction, value: string | number | Date) {\n  const isComparable = typeof value === 'string' || typeof value === 'number' || value instanceof Date;\n\n  if (!isComparable) {\n    throw new Error(`\"${instruction.name}\" expects value to be comparable (i.e., string, number or date)`);\n  }\n}\n\nconst ensureIs = (type: string) => (instruction: NamedInstruction, value: unknown) => {\n  if (typeof value !== type) { // eslint-disable-line valid-typeof\n    throw new Error(`\"${instruction.name}\" expects value to be a \"${type}\"`);\n  }\n};\n\nexport const $and: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n  parse(instruction, queries, { parse }) {\n    const conditions = queries.map(query => parse(query));\n    return optimizedCompoundCondition(instruction.name, conditions);\n  }\n};\nexport const $or = $and;\nexport const $nor: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n};\n\nexport const $not: FieldInstruction<MongoQuery<any> | RegExp> = {\n  type: 'field',\n  validate(instruction, value) {\n    const isValid = value && (value instanceof RegExp || value.constructor === Object);\n\n    if (!isValid) {\n      throw new Error(`\"${instruction.name}\" expects to receive either regular expression or object of field operators`);\n    }\n  },\n  parse(instruction, value, context) {\n    const condition = value instanceof RegExp\n      ? new FieldCondition('regex' as typeof instruction.name, context.field, value)\n      : context.parse(value, context);\n\n    return new CompoundCondition(instruction.name, [condition]);\n  },\n};\nexport const $elemMatch: FieldInstruction<MongoQuery<any>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!value || value.constructor !== Object) {\n      throw new Error(`\"${instruction.name}\" expects to receive an object with nested query or field level operators`);\n    }\n  },\n  parse(instruction, value, { parse, field, hasOperators }) {\n    const condition = hasOperators(value) ? parse(value, { field: ITSELF }) : parse(value);\n    return new FieldCondition(instruction.name, field, condition);\n  }\n};\n\nexport const $size: FieldInstruction<number> = {\n  type: 'field',\n  validate: ensureIs('number')\n};\nexport const $in: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate: ensureIsArray,\n};\nexport const $nin = $in;\nexport const $all = $in;\nexport const $mod: FieldInstruction<[number, number]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value) || value.length !== 2) {\n      throw new Error(`\"${instruction.name}\" expects an array with 2 numeric elements`);\n    }\n  }\n};\n\nexport const $exists: FieldInstruction<boolean> = {\n  type: 'field',\n  validate: ensureIs('boolean'),\n};\n\nexport const $gte: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate: ensureIsComparable\n};\nexport const $gt = $gte;\nexport const $lt = $gt;\nexport const $lte = $gt;\n\nexport const $eq: FieldInstruction = {\n  type: 'field',\n};\nexport const $ne = $eq;\n\nexport interface RegExpFieldContext extends FieldParsingContext {\n  query: {\n    $options?: string\n  }\n}\n\nexport const $regex: FieldInstruction<string | RegExp, RegExpFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!(value instanceof RegExp) && typeof value !== 'string') {\n      throw new Error(`\"${instruction.name}\" expects value to be a regular expression or a string that represents regular expression`);\n    }\n  },\n  parse(instruction, rawValue, context) {\n    const value = typeof rawValue === 'string'\n      ? new RegExp(rawValue, context.query.$options || '')\n      : rawValue;\n    return new FieldCondition(instruction.name, context.field, value);\n  }\n};\nexport const $options: FieldInstruction = {\n  type: 'field',\n  parse: () => NULL_CONDITION,\n};\n\nexport const $where: DocumentInstruction<() => boolean> = {\n  type: 'document',\n  validate: ensureIs('function'),\n};\n","import {\n  Condition,\n  buildAnd as and,\n  ParsingInstruction,\n  ObjectQueryParser,\n  FieldQueryOperators,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nexport interface ParseOptions {\n  field: string\n}\n\nexport class MongoQueryParser extends ObjectQueryParser<MongoQuery<any>> {\n  constructor(instructions: Record<string, ParsingInstruction>) {\n    super(instructions, {\n      defaultOperatorName: '$eq',\n      operatorToConditionName: name => name.slice(1),\n    });\n  }\n\n  parse<Q extends MongoQuery<any>, FQ extends FieldQueryOperators<Q> = FieldQueryOperators<Q>>(\n    query: Q | FQ,\n    options?: ParseOptions\n  ): Condition {\n    if (options && options.field) {\n      return and(this.parseFieldOperators(options.field, query as FQ));\n    }\n\n    return super.parse(query);\n  }\n}\n","import * as instructions from './instructions';\n\nexport const allParsingInstructions = instructions;\nexport * from './instructions';\nexport * from './MongoQueryParser';\nexport * from './types';\nexport { defaultInstructionParsers as defaultParsers } from '@ucast/core';\n","import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => !!value && value.hasOwnProperty(field) === node.value;\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n","import { createTranslatorFactory, ParsingInstruction, Condition, ITSELF } from '@ucast/core';\nimport {\n  MongoQuery,\n  MongoQueryParser,\n  MongoQueryFieldOperators,\n  allParsingInstructions,\n  defaultParsers\n} from '@ucast/mongo';\nimport {\n  createJsInterpreter,\n  allInterpreters,\n  JsInterpreter,\n  JsInterpretationOptions,\n  compare\n} from '@ucast/js';\n\ntype ThingFilter<T> = {\n  (object: T): boolean\n  ast: Condition\n};\n\ninterface HasToJSON {\n  toJSON(): unknown\n}\n\nfunction toPrimitive(value: unknown) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  if (value && typeof (value as HasToJSON).toJSON === 'function') {\n    return (value as HasToJSON).toJSON();\n  }\n\n  return value;\n}\n\nconst comparePrimitives: typeof compare = (a, b) => compare(toPrimitive(a), toPrimitive(b));\n\nexport interface FactoryOptions extends JsInterpretationOptions {\n  forPrimitives: boolean\n}\n\nexport type Filter = <\n  T = Record<string, unknown>,\n  Q extends MongoQuery<T> = MongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\nexport type PrimitiveMongoQuery<T> = MongoQueryFieldOperators<T> & Partial<{\n  $and: MongoQueryFieldOperators<T>[],\n  $or: MongoQueryFieldOperators<T>[],\n  $nor: MongoQueryFieldOperators<T>[]\n}>;\nexport type PrimitiveFilter = <\n  T,\n  Q extends PrimitiveMongoQuery<T> = PrimitiveMongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\ntype FilterType<T extends { forPrimitives?: true }> = T['forPrimitives'] extends true\n  ? PrimitiveFilter\n  : Filter;\n\nexport function createFactory<\n  T extends Record<string, ParsingInstruction<any, any>>,\n  I extends Record<string, JsInterpreter<any>>,\n  P extends { forPrimitives?: true }\n>(instructions: T, interpreters: I, options?: Partial<FactoryOptions> & P): FilterType<P> {\n  const parser = new MongoQueryParser(instructions);\n  const interpret = createJsInterpreter(interpreters, {\n    compare: comparePrimitives,\n    ...options\n  });\n\n  if (options && options.forPrimitives) {\n    const params = { field: ITSELF };\n    const parse = parser.parse;\n    parser.setParse(query => parse(query, params));\n  }\n\n  return createTranslatorFactory(parser.parse, interpret) as any;\n}\n\nexport const guard = createFactory(allParsingInstructions, allInterpreters);\n\nconst compoundOperators = ['$and', '$or'] as const;\nconst allPrimitiveParsingInstructions = compoundOperators.reduce((instructions, name) => {\n  instructions[name] = { ...instructions[name], type: 'field' } as any;\n  return instructions;\n}, {\n  ...allParsingInstructions,\n  $nor: {\n    ...allParsingInstructions.$nor,\n    type: 'field',\n    parse: defaultParsers.compound\n  }\n});\n\nexport const squire = createFactory(allPrimitiveParsingInstructions, allInterpreters, {\n  forPrimitives: true\n});\nexport const filter = guard; // TODO: remove in next major version\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n","import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!object.hasOwnProperty(TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport const getSubjectTypeName = (value: SubjectType) => {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n};\n\nexport function detectSubjectType(subject: Exclude<Subject, SubjectType>): string {\n  if (subject.hasOwnProperty(TYPE_FIELD)) {\n    return (subject as any)[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(subject.constructor as SubjectClass);\n}\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (aliasMap.hasOwnProperty(action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\ndeclare const $abilities: unique symbol;\ndeclare const $conditions: unique symbol;\ninterface WithGenerics {\n  [$abilities]: any\n  [$conditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof $abilities],\n  conditions: T[typeof $conditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\nconst analyze = (index: any, rule: Rule<any, any>) => {\n  if (!index._hasPerFieldRules && rule.fields) {\n    index._hasPerFieldRules = true;\n  }\n};\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events: Events<this> = new Map();\n  private _indexedRules!: IndexTree<A, Conditions>;\n  private _rules!: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions!: RuleOptions<Conditions>;\n  private readonly _detectSubjectType!: Required<RuleIndexOptions<A, Conditions>>['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  readonly [$abilities]!: A;\n  readonly [$conditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._detectSubjectType = options.detectSubjectType || detectSubjectType;\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object;\n    if (!object) return this._anySubjectType;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexedRules = this._buildIndexFor(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _buildIndexFor(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      analyze(this, rule);\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    return indexedRules;\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[]\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[]\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    const tail = this._events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    this._events.set(event, item);\n\n    return () => {\n      const currentTail = this._events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        this._events.delete(event);\n      } else if (item === currentTail) {\n        this._events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean {\n    const rule = this.relevantRuleFor(...args);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean {\n    return !this.can(...args);\n  }\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T extends {}, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public } from './RuleIndex';\n\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<Ability<any, MongoQuery>> {}\n","import { Ability, AnyMongoAbility } from './Ability';\nimport { AnyAbility, AbilityOptionsOf, AbilityClass } from './PureAbility';\nimport { RawRuleOf, Generics } from './RuleIndex';\nimport {\n  ExtractSubjectType as E,\n  AbilityTuple,\n  SubjectType,\n  TaggedInterface,\n  Normalize,\n  AnyObject,\n  AnyClass,\n} from './types';\nimport { ProduceGeneric } from './hkt';\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends string\n    ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n      ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n      : AnyObject\n    : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends T[1] ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private _AbilityType!: AnyClass<T>;\n\n  constructor(AbilityType: AnyClass<T>) {\n    this._AbilityType = AbilityType;\n    this.can = this.can.bind(this as any);\n    this.cannot = this.cannot.bind(this as any);\n    this.build = this.build.bind(this as any);\n  }\n\n  can<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  can<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  can(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions']\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n\n    return new RuleBuilder(rule);\n  }\n\n  cannot<\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>\n  cannot<\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>\n  cannot(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n  ): RuleBuilder<T> {\n    const builder = (this as any).can(action, subject, conditionsOrFields, conditions);\n    builder._rule.inverted = true;\n    return builder;\n  }\n\n  build(options?: AbilityOptionsOf<T>) {\n    return new this._AbilityType(this.rules, options);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder(Ability as unknown as AbilityClass<T>);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U) {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string) {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>) {\n    const rule = this.ability.relevantRuleFor(...args);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = args[0];\n    this.subject = args[1];\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(args[1]));\n    this.field = args[2];\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    throw this; // eslint-disable-line\n  }\n}\n","import { Children, ReactNodeArray, PureComponent, Fragment, createElement } from 'react';\nimport {\n  Unsubscribe,\n  AbilityTuple,\n  SubjectType,\n  AnyAbility,\n  Generics,\n  Abilities,\n  IfString,\n} from '@casl/ability';\n\nconst noop = () => {};\nconst renderChildren = Fragment\n  ? (children?: ReactNodeArray) => {\n    if (!children) {\n      return null;\n    }\n\n    return children.length > 1\n      ? createElement(Fragment, null, ...children)\n      : Children.only(children);\n  }\n  : Children.only;\n\ntype AbilityCanProps<\n  T extends Abilities,\n  Else = IfString<T, { do: T } | { I: T }>\n> = T extends AbilityTuple\n  ? { do: T[0], on: T[1], field?: string } |\n  { I: T[0], a: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], an: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], this: Exclude<T[1], SubjectType>, field?: string }\n  : Else;\n\ninterface ExtraProps {\n  not?: boolean\n  passThrough?: boolean\n}\n\ninterface CanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability: T\n}\n\ninterface BoundCanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability?: T\n}\n\nexport type CanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & CanExtraProps<T>;\nexport type BoundCanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & BoundCanExtraProps<T>;\n\nexport class Can<\n  T extends AnyAbility,\n  IsBound extends boolean = false\n> extends PureComponent<IsBound extends true ? BoundCanProps<T> : CanProps<T>> {\n  private _isAllowed: boolean = false;\n  private _ability: T | null = null;\n  private _unsubscribeFromAbility: Unsubscribe = noop;\n\n  componentWillUnmount() {\n    this._unsubscribeFromAbility();\n  }\n\n  private _connectToAbility(ability?: T) {\n    if (ability === this._ability) {\n      return;\n    }\n\n    this._unsubscribeFromAbility();\n    this._ability = null;\n\n    if (ability) {\n      this._ability = ability;\n      this._unsubscribeFromAbility = ability.on('updated', () => this.forceUpdate());\n    }\n  }\n\n  get allowed() {\n    return this._isAllowed;\n  }\n\n  private _canRender(): boolean {\n    const props: any = this.props;\n    const subject = props.of || props.a || props.an || props.this || props.on;\n    const can = props.not ? 'cannot' : 'can';\n\n    return props.ability[can](props.I || props.do, subject, props.field);\n  }\n\n  render() {\n    this._connectToAbility(this.props.ability);\n    this._isAllowed = this._canRender();\n    return this.props.passThrough || this._isAllowed ? this._renderChildren() : null;\n  }\n\n  private _renderChildren() {\n    const { children, ability } = this.props;\n    const elements = typeof children === 'function'\n      ? children(this._isAllowed, ability)\n      : children;\n\n    return renderChildren(elements);\n  }\n}\n","import React from 'react';\r\nimport { Row, Col, Button, ButtonGroup, ListGroup, ListGroupItem } from 'reactstrap';\r\nimport { defineAbility } from '@casl/ability';\r\nimport { Can } from '@casl/react';\r\nimport ComponentCard from '../../../components/ComponentCard';\r\n\r\nconst permissions = {\r\n  CanEdit: {\r\n    action: 'Can-edit',\r\n    subject: 'address',\r\n  },\r\n  CanDelete: {\r\n    action: 'Can-delete',\r\n    subject: 'address',\r\n  },\r\n};\r\n\r\nconst users = {\r\n  admin: {\r\n    permissions: ['CanEdit', 'CanDelete'],\r\n  },\r\n  Manager: {\r\n    permissions: ['CanEdit'],\r\n  },\r\n  SubscriberReadOnly: {\r\n    permissions: [],\r\n  },\r\n};\r\n\r\nconst addresses = [\r\n  {\r\n    city: 'New York',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n  {\r\n    city: 'Manhatten York',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n  {\r\n    city: 'Canada street York',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n  {\r\n    city: 'Delhi street',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n  {\r\n    city: 'UP Chawk',\r\n    street: '5684 Max Summit',\r\n    type: 'address',\r\n  },\r\n];\r\n\r\nconst AccessControl = () => {\r\n  const [userId, setUserId] = React.useState(Object.keys(users)[0]);\r\n  const userPermissions = users[userId].permissions.map((id) => permissions[id]);\r\n\r\n  const actions = [\r\n    ...userPermissions.reduce((collection, { action }) => {\r\n      collection.add(action);\r\n      return collection;\r\n    }, new Set()),\r\n  ];\r\n\r\n  const ability = defineAbility((can) => {\r\n    userPermissions.forEach(({ action, subject }) => {\r\n      can(action, subject);\r\n    });\r\n  });\r\n  return (\r\n    <Row>\r\n      <Col lg=\"12\">\r\n        {/* --------------------------------------------------------------------------------*/}\r\n        {/* Card-1*/}\r\n        {/* --------------------------------------------------------------------------------*/}\r\n        <ComponentCard title=\"Roll base Access\">\r\n          <ButtonGroup>\r\n            {Object.entries(users).map(([id]) => (\r\n              <Button\r\n                key={id}\r\n                outline={userId !== id}\r\n                color=\"primary\"\r\n                onClick={() => setUserId(id)}\r\n              >\r\n                {id}\r\n              </Button>\r\n            ))}\r\n          </ButtonGroup>\r\n          <div className=\"p-3 bg-light mt-3\">\r\n            {users[userId].permissions.map((permission) => (\r\n              <div key={permission}>{permission}</div>\r\n            ))}\r\n          </div>\r\n          <ListGroup className=\"mt-4\">\r\n            {addresses.map(({ city, street, type }) => (\r\n              <ListGroupItem key={city}>\r\n                <div>\r\n                  {city}, {street}\r\n                  {actions.map((action) => (\r\n                    <Can I={action} a={type} ability={ability}>\r\n                      <Button className=\"mx-1\" size=\"sm\">\r\n                        {action}\r\n                      </Button>\r\n                    </Can>\r\n                  ))}\r\n                </div>\r\n              </ListGroupItem>\r\n            ))}\r\n          </ListGroup>\r\n        </ComponentCard>\r\n      </Col>\r\n    </Row>\r\n  );\r\n};\r\n\r\nexport default AccessControl;\r\n","import React from 'react';\r\nimport { CardTitle, Row, Col } from 'reactstrap';\r\nimport PropTypes from 'prop-types';\r\n\r\nexport default function CreationModification({ details = null, title }) {\r\n  CreationModification.propTypes = {\r\n    details: PropTypes.object,\r\n    title: PropTypes.string,\r\n  };\r\n  return (\r\n    <>\r\n      <CardTitle tag=\"h4\" className=\"border-bottom px-4 py-3 mb-0\">\r\n        <Row>\r\n          <Col>{title}</Col>\r\n          {details && (\r\n            <Col>\r\n              <Row>\r\n                <small> Creation: {details && details.created_by} {details && details.creation_date}</small>\r\n              </Row>\r\n              <Row className=\"d-flex\">\r\n                <small> Modified: {details && details.modified_by} {details && details.modification_date}</small>\r\n              </Row>\r\n            </Col>\r\n          )}\r\n        </Row>\r\n      </CardTitle>\r\n    </>\r\n   );\r\n}","import { Card, CardBody, CardSubtitle } from 'reactstrap';\r\nimport PropTypes from 'prop-types';\r\nimport CreationModification from './CreationModification';\r\n\r\nconst ComponentCard = ({ children, title, subtitle,creationModificationDate }) => {\r\n  return (\r\n    <Card className='shadow-none'>\r\n      <CreationModification details={creationModificationDate} title={title}></CreationModification>\r\n      {/* <CardTitle tag=\"h4\" className=\"border-bottom px-4 py-3 mb-0\">\r\n        {title}\r\n        <p tag='h2' className=\"float-end small fs-5\">{righttitle}</p>\r\n      </CardTitle> */}\r\n      <CardBody className=\"p-4\">\r\n        <CardSubtitle className=\"text-muted mb-3\">{subtitle || ''}</CardSubtitle>\r\n        <div>{children}</div>\r\n      </CardBody>\r\n    </Card>\r\n  );\r\n};\r\n\r\nComponentCard.propTypes = {\r\n  children: PropTypes.node,\r\n  title: PropTypes.string,\r\n  subtitle: PropTypes.node,\r\n  creationModificationDate:PropTypes.any\r\n};\r\n\r\nexport default ComponentCard;\r\n"],"names":["t","constructor","e","operator","value","Object","defineProperty","this","writable","notes","addNote","push","r","Array","isArray","Error","concat","n","o","field","s","i","prototype","hasOwnProperty","call","bind","c","u","length","a","h","object","create","f","d","p","w","O","compound","map","parse","name","document","j","arguments","undefined","operatorToConditionName","defaultOperatorName","mergeFinalConditions","keys","reduce","assign","fieldContext","query","hasOperators","l","useIgnoreValue","documentContext","setParse","parseField","type","parseInstruction","validate","parseFieldOperators","_","y","_ref","RegExp","$","_ref2","x","v","m","g","Date","b","E","R","$options","q","A","N","freeze","__proto__","$and","$or","$nor","$not","$elemMatch","$size","$in","$nin","$all","$mod","$exists","$gte","$gt","$lt","$lte","$eq","$ne","$regex","$where","P","slice","super","z","Number","isNaN","get","some","defaultGet","lastIndexOf","String","indexOf","split","getInterpreterName","numberOfArguments","interpret","compare","or","and","every","eq","_ref4","ne","exists","_ref5","size","_ref6","test","_ref7","nin","all","_ref8","elemMatch","_ref9","M","nor","not","_ref3","lte","lt","gt","gte","mod","regex","within","where","S","in","getTime","toJSON","comparePrimitives","forPrimitives","_len","_key","ast","C","T","B","modelName","I","L","priority","U","set","G","J","fields","fieldMatcher","conditions","conditionsMatcher","H","action","resolveAction","subject","inverted","reason","matchesConditions","matchesField","Q","prev","next","V","defaultActionEntry","rules","merged","W","defaultSubjectEntry","Map","X","analyze","Z","anyAction","anySubjectType","detectSubjectType","update","ability","target","possibleRulesFor","has","rulesFor","filter","on","K","delete","PureAbility","can","relevantRuleFor","cannot","tt","et","F","st","nt","rt","ot","ct","ut","replace","ht","at","join","Ability","ft","because","AbilityBuilder","build","pt","message","setDefaultMessage","from","captureStackTrace","setMessage","throwUnlessCan","subjectType","noop","only","componentWillUnmount","forceUpdate","allowed","props","of","an","do","render","passThrough","children","permissions","CanEdit","CanDelete","users","admin","Manager","SubscriberReadOnly","addresses","city","street","AccessControl","userId","setUserId","React","userPermissions","id","actions","collection","add","Set","then","defineAbility","forEach","_jsx","Row","Col","lg","_jsxs","ComponentCard","title","ButtonGroup","entries","Button","outline","color","onClick","className","permission","ListGroup","ListGroupItem","Can","CreationModification","details","_Fragment","CardTitle","tag","created_by","creation_date","modified_by","modification_date","subtitle","creationModificationDate","Card","CardBody","CardSubtitle"],"sourceRoot":""}